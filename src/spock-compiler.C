static const char *purpose = "wrapper around system-installed compilers";
static const char *description =
    "This program is a wrapper around compilers that are already installed on the system. It ensures that the compiler has "
    "the expected version number and fails loudly if not.  This avoids problems that are encountered when one has a large "
    "collection of software generated by one compiler and then some system administrator or upgrade daemon installs a new "
    "compiler in its place.  When this happens, it is generally best to recompile said software in order to prevent subtle "
    "bugs that can appear when linking programs with parts generated by a variety of compilers.\n\n"

    "All command-line arguments are passed directly to the backend compiler except switches beginning with @s{spock-}, "
    "and these switches must appear before all other arguments.";

#include <Spock/Spock.C>

#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <boost/filesystem.hpp>
#include <sys/wait.h>
#include <yaml-cpp/yaml.h>

using namespace Spock;
using namespace Sawyer::Message::Common;

namespace {

Sawyer::Message::Facility mlog;
bool showTriplet = false, showBaseExe = false;
boost::filesystem::path configFileOverride;

std::vector<std::string>
parseCommandLine(int argc, char *argv[]) {
    using namespace Sawyer::CommandLine;
    Parser p;
    p.errorStream(mlog[FATAL]);
    p.purpose(purpose);
    p.doc("Description", description);
    p.resetInclusionPrefixes();
    p.skippingUnknownSwitches(true);
    p.skippingNonSwitches(true);

    SwitchGroup sp("Spock-specific switches");

    sp.insert(Switch("spock-help")
              .action(showHelpAndExit(0))
              .doc("Show this documentation."));

    sp.insert(Switch("spock-version")
              .action(showVersionAndExit(Spock::VERSION, 0))
              .doc("Show the Spock version number, then exit."));

    sp.insert(Switch("spock-log")
              .action(configureDiagnostics("spock-log", Sawyer::Message::mfacilities))
              .argument("config")
              .whichValue(SAVE_ALL)
              .doc("Configure diagnostics.  Use \"@s{spock-log}=help\" and \"@s{spock-log}=list\" to get started."));

    sp.insert(Switch("spock-triplet")
              .intrinsicValue(true, showTriplet)
              .doc("Echo compiler information to standard output instead of running the compiler.  The information consists "
                   "of the following fields separated by colons: vendor name, language, and version."));

    sp.insert(Switch("spock-exe")
              .intrinsicValue(true, showBaseExe)
              .doc("Echo the full path of the real compiler, then exit."));

    sp.insert(Switch("spock-config")
              .argument("filename", anyParser(configFileOverride))
              .doc("Name of configuration file. Normally the configuration file is named \"compiler.yaml\" and appears in "
                   "the same directory as this wrapper."));

    return p.with(sp).parse(argc, argv).apply().skippedArgs();
}

void
checkScalar(YAML::Node config, const std::string &fieldName, const boost::filesystem::path &configName) {
    if (!config[fieldName] || config[fieldName].Type() != YAML::NodeType::Scalar) {
        mlog[ERROR] <<"missing or incorrect type \"" <<fieldName <<" in " <<configName <<"\n";
        exit(1);
    }
}

// Find a compiler configuration file in the same directory as this executable.
YAML::Node
readConfigFile(const boost::filesystem::path &arg0) {
    boost::filesystem::path configName;
    if (configFileOverride.empty()) {
        configName = boost::filesystem::read_symlink("/proc/self/exe").parent_path() / "compiler.yaml";
    } else {
        configName = configFileOverride;
    }
    
    if (!boost::filesystem::exists(configName)) {
        mlog[ERROR] <<"missing compiler config file: " <<configName <<"\n";
        exit(1);
    }
    YAML::Node config = YAML::LoadFile(configName.string());
    checkScalar(config, "executable", configName);
    checkScalar(config, "language", configName);
    checkScalar(config, "vendor", configName);
    checkScalar(config, "version", configName);
    checkScalar(config, "version-output", configName);

    if (!config["flags"] || config["flags"].Type() != YAML::NodeType::Sequence) {
        mlog[ERROR] <<"missing or incorrect type \"flags\" in " <<configName <<"\n";
        exit(1);
    }
    
    return config;
}

// Validate that the executable still exists.
void
validateExecutable(YAML::Node config) {
    boost::filesystem::path exe = config["executable"].as<std::string>();
    if (!boost::filesystem::exists(exe)) {
        mlog[ERROR] <<"missing compiler executable " <<exe <<"\n";
        exit(1);
    }
}

// Runs the compiler with "--version" and checks that output against output that was generated previously and placed in the
// config file.
void
validateVersion(YAML::Node config) {
    boost::filesystem::path exe = config["executable"].as<std::string>();
    std::string compilerName = exe.filename().string();
    std::string childOutput;
    std::string oldOutput = config["version-output"].as<std::string>();

    int childToParent[2];
    pipe(childToParent);
    pid_t child = fork();
    if (-1 == child) {
        mlog[FATAL] <<"fork failed: " <<strerror(errno) <<"\n";
        exit(1);
    } else if (child) {
        // This is the parent
        close(childToParent[1]);
        while (1) {
            char buf[4096];
            ssize_t nread = TEMP_FAILURE_RETRY(read(childToParent[0], buf, sizeof buf));
            if (-1 == nread) {
                mlog[FATAL] <<"read from child failed: " <<strerror(errno) <<"\n";
                break;
            } else if (0 == nread) {
                break;
            } else {
                childOutput += std::string(buf, buf+nread);
            }
        }
        close(childToParent[0]);
        int status = 0;
        waitpid(child, &status, 0);
        if (!WIFEXITED(status) || WEXITSTATUS(status)!=0) {
            mlog[ERROR] <<"compiler check did not exit with successful status\n";
            exit(1);
        }
    } else {
        // This is the child
        close(childToParent[0]);
        dup2(childToParent[1], 1);
        char *argv[3];
        argv[0] = strdup(exe.string().c_str());
        argv[1] = strdup("--version");
        argv[2] = NULL;
        execv(exe.string().c_str(), argv);
        std::cerr <<"compiler " <<compilerName <<" failed to exec: " <<strerror(errno) <<"\n";
        exit(1);
    }

    // When comparing old and new lines, remove all white space first.
    std::string newStripped, oldStripped;
    BOOST_FOREACH (char ch, childOutput) {
        if (!isspace(ch))
            newStripped += ch;
    }
    BOOST_FOREACH (char ch, oldOutput) {
        if (!isspace(ch))
            oldStripped += ch;
    }
    if (newStripped != oldStripped) {
        mlog[ERROR] <<"compiler version info differs from original output\n";
        mlog[ERROR] <<"original output:\n";
        std::vector<std::string> lines;
        boost::split(lines, oldOutput, boost::is_any_of("\n"));
        BOOST_FOREACH (const std::string &line, lines) {
            if (!boost::trim_copy(line).empty())
                mlog[ERROR] <<"  |" <<line <<"\n";
        }

        mlog[ERROR] <<"current output:\n";
        lines.clear();
        boost::split(lines, childOutput, boost::is_any_of("\n"));
        BOOST_FOREACH (const std::string &line, lines) {
            if (!boost::trim_copy(line).empty())
                mlog[ERROR] <<"  |" <<line <<"\n";
        }
        exit(1);
    }
}

void
execCompiler(YAML::Node config, std::vector<std::string> &args) {
    boost::filesystem::path exe = config["executable"].as<std::string>();
    size_t nargs = 1 + config["flags"].size() + args.size() + 1;
    char **argv = new char*[nargs];
    int argc = 0;
    argv[argc++] = strdup(exe.string().c_str());
    for (size_t i=0; i<config["flags"].size(); ++i)
        argv[argc++] = strdup(config["flags"][i].as<std::string>().c_str());
    for (size_t i=0; i<args.size(); ++i)
        argv[argc++] = strdup(args[i].c_str());
    argv[argc] = NULL;

    if (mlog[DEBUG]) {
        mlog[DEBUG] <<"launching " <<exe <<" with this argv:\n";
        for (int i=0; i<argc; ++i)
            mlog[DEBUG] <<"  \"" <<argv[i] <<"\"\n";
    }

    execv(exe.string().c_str(), argv);
    mlog[ERROR] <<"failed to launch compiler: " <<exe <<"\n";
    exit(1);
}

    

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace

int
main(int argc, char *argv[]) {
    Spock::initialize(mlog);
    std::vector<std::string> args = parseCommandLine(argc, argv);
    YAML::Node config = readConfigFile(argv[0]);

    if (showTriplet) {
        std::cout <<config["vendor"].as<std::string>() <<":"
                  <<config["language"].as<std::string>() <<":"
                  <<config["version"].as<std::string>() <<"\n";
    } else if (showBaseExe) {
        std::cout <<config["executable"].as<std::string>() <<"\n";
    }

    validateExecutable(config);
    validateVersion(config);

    if (!showTriplet && !showBaseExe)
        execCompiler(config, args);
}
